<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                         "http://www.docbook.org/xml/4.5/docbookx.dtd" [
                         <!ENTITY % xinclude SYSTEM "../docbook/xinclude.mod" >
                         %xinclude;
                         <!ENTITY % local.common.attrib "xml:base CDATA #IMPLIED" >
]>

<section id="core">
  <title>DMLex Core</title>
  <para>The DMLex Core provides data types for modelling monolingual dictionaries (called <emphasis>lexicographic resources</emphasis> in DMLex) where headwords, definitions and examples are all in one and the same language. DMLex Core gives you the tools you need to model simple dictionary entries which consist of the following data types:</para>
  <itemizedlist>
    <listitem>
			<para><literal><olink targetptr="core_lexicographicResource">lexicographicResource</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_entry">entry</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_partOfSpeech">partOfSpeech</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_inflectedForm">inflectedForm</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_sense">sense</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_definition">definition</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_label">label</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_pronunciation">pronunciation</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_transcription">transcription</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_example">example</olink></literal></para>
    </listitem>
  </itemizedlist>
  <simplesect id="optionalroots">
    <title>Optional roots</title>
    <para>
      When exchanging data encoded in a DMLex serialization
      which has the concept of a "root" or top-level object, such as XML, JSON or NVH,
      the object types <literal>lexicographicResource</literal> and <literal>entry</literal>
      can serve as such roots.
    </para>
  </simplesect>
  <simplesect id="fragid">
    <title>Fragment identification</title>
    <para>
      Incomplete parts of DMLex objects represent valid fragments as long as it is possible to identify their complete source DMLex object.
      For a particular serialization, this can be achieved by:
      <itemizedlist>
        <listitem>
          <para>Making sure the fragment contains all <olink targetptr="uniqueids">unique properties</olink> of the DMLex parent-child hierarchy that are necessary to determine its source object.</para>
        </listitem>
        <listitem>
          <para>Using a serialization-specific addressing mechanism (e.g. XPath for XML, JMESPath for JSON or an NVH query) to provide the location of the fragment in the source DMLex object.</para>
        </listitem>
     </itemizedlist>
	</para>
  </simplesect>
  <simplesect id="fraguri">
	  <title>Fragment URIs</title>
	  <para>Every fragment <glossterm>should</glossterm> be assigned a unique URI, identifying it on the Web, composed of <literal>lexicographicResource.uri</literal> and a sequence of identifiers that uniquely determines the path in the DMLex tree structure. The URI of the root object <literal>lexicographicResource</literal> is the value of its attribute <literal>lexicographicResource.uri</literal>. The URIs of its direct children are constructed as follows:</para>

	<para><literal>lexicographicResource.uri/objectTypeName/objectID</literal></para>

	<para>(We define below how object IDs are created.)</para>

	<para>The URIs of descendant objects are constructed by appending the children's type names and IDs to the URI of their direct parents, using “/” as the delimiter. In other words, the full template for an URI object looks as follows:</para>


	<para><literal>lexicographicResource.uri/objectTypeName/objectID/child1TypeName/child1ID/child2TypeName/child2ID/…</literal></para>

	<para>For example, a particular sense (which is a property of entry) is assigned the following URI:</para>


	<para><literal>lexicographicResource.uri/entry/entryID/sense/senseID</literal></para>

	<para>URI of an example (which is a property of sense, which is a property of entry) has the following structure:</para>

	<para><literal>lexicographicResource.uri/entry/entryID/sense/senseID/example/exampleID</literal></para>

	<bridgehead>Object IDs</bridgehead>

	<para>For the purpose of creating URIs, each object is assigned a unique ID, based on values of its properties declared as <glossterm>unique</glossterm>. Multiple situations can occur:</para>

	<orderedlist>
		<listitem>The object type has a single <glossterm>unique</glossterm> property with an arity of “exactly one”, and the value of the property is a string or a number. In this case, the object ID is the string or the number, with the following modifications performed in that particular order:
			<itemizedlist>
				<listitem>every “\” (ASCII character 5C) is replaced by “\\”</listitem>
				<listitem>every “~” (ASCII character 7E) is replaced by “\~”</listitem>
				<listitem>every “_” (ASCII character 5F) is replaced by “\_”</listitem>
				<listitem>the result is percent-encoded according to [<link linkend="bib_rfc3986">RFC 3986</link>]</listitem>
			</itemizedlist>
		</listitem>
		<listitem>The object type has a single <glossterm>unique</glossterm> property with an arity of “exactly one”, and the value of the property is a child DMLex object. In this case, the object ID is the same as the object ID of the child object.</listitem>
		<listitem>The object type has a single <glossterm>unique</glossterm> property with arbitrary arity. In this case, all the partial single values or child object IDs are constructed according to the steps 1. and 2., and the resulting object ID is their concatenation using “_” (ASCII character 5F) as a separator. (Note: this allows empty IDs in case of <glossterm>unique</glossterm> attributes which allow the arity of zero.)</listitem>
		<listitem>The object type has multiple <glossterm>unique</glossterm> properties. In this case, all the partial values or child object IDs are constructed according to the steps 1., 2. and 3., and the resulting object ID is their concatenation using “~” (ASCII character 5F) as a separator. (Note: this allows empty IDs in case of multiple <glossterm>unique</glossterm> attributes, all of them allowing the arity of zero.)</listitem>
	</orderedlist>

	<para>The standard does not define the structure of URIs for object types without <glossterm>unique</glossterm> properties.</para>

  </simplesect>
  <xi:include href="objectTypes/lexicographicResource.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/entry.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/partOfSpeech.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/inflectedForm.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/sense.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/definition.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/label.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/pronunciation.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/transcription.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/example.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
</section>
