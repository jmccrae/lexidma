<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                         "http://www.docbook.org/xml/4.5/docbookx.dtd" [
                         <!ENTITY % xinclude SYSTEM "../docbook/xinclude.mod" >
                         %xinclude;
                         <!ENTITY % local.common.attrib "xml:base CDATA #IMPLIED" >
]>

<section id="core">
  <title>DMLex Core</title>
  <para>The DMLex Core provides data types for modelling monolingual dictionaries (called <emphasis>lexicographic resources</emphasis> in DMLex) where headwords, definitions and examples are all in one and the same language. DMLex Core gives you the tools you need to model simple dictionary entries which consist of the following data types:</para>
  <itemizedlist>
    <listitem>
			<para><literal><olink targetptr="core_lexicographicResource">lexicographicResource</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_entry">entry</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_partOfSpeech">partOfSpeech</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_inflectedForm">inflectedForm</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_sense">sense</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_definition">definition</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_label">label</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_pronunciation">pronunciation</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_transcription">transcription</olink></literal></para>
    </listitem>
    <listitem>
			<para><literal><olink targetptr="core_example">example</olink></literal></para>
    </listitem>
  </itemizedlist>
  <section id="optionalroots">
    <title>Optional roots</title>
    <para>
      When exchanging data encoded in a DMLex serialization
      which has the concept of a "root" or top-level object, such as XML, JSON or NVH,
      the object types <literal>lexicographicResource</literal> and <literal>entry</literal>
      can serve as such roots.
    </para>
  </section>
  <section id="fragid">
    <title>Fragment identification</title>
    <para>
      Incomplete parts of DMLex objects represent valid fragments as long as it is possible to identify their complete source DMLex object.
      For a particular serialization, this can be achieved by:
      <itemizedlist>
        <listitem>
          <para>Making sure the fragment contains all <olink targetptr="uniqueids">unique properties</olink> of the DMLex parent-child hierarchy that are necessary to determine its source object.</para>
        </listitem>
        <listitem>
          <para>Using a serialization-specific addressing mechanism (e.g. XPath for XML, JMESPath for JSON or an NVH query) to provide the location of the fragment in the source DMLex object.</para>
        </listitem>
     </itemizedlist>
	</para>
	  <section id="frag_iri">
		  <title>Fragment IRIs</title>
		  <para>DMLex provides a recommended method for addressing DMLex objects present on-line, useful for linking (cf. <xref linkend="linking"/>) and general interoperability. Implementing this method is not <glossterm>required</glossterm> for conformance.</para>

		  <para>Every fragment <glossterm>should</glossterm> be assigned a unique IRI (Internationalized Resource Identifier [<link linkend="bib_rfc3987">RFC 3987</link>]), composed of <literal>lexicographicResource.uri</literal> and a sequence of identifiers that uniquely determines the path in the DMLex tree structure. The IRI of the root object <literal>lexicographicResource</literal> is the value of its attribute <literal>lexicographicResource.uri</literal>, converted to IRI according to the algorithm specified in [<link linkend="bib_rfc3987">RFC 3987</link>], if needed. The IRIs of its direct children are constructed as follows:</para>

		<para><literal>lexicographicResource.uri/objectTypeName/objectID</literal></para>

		<para>(We define below how object IDs are created.)</para>

		<para>The IRIs of descendant objects are constructed by appending the children's type names and IDs to the IRI of their direct parents, using “/” as the delimiter. In other words, the full template for an IRI object looks as follows:</para>

		<para><literal>lexicographicResource.uri/objectTypeName/objectID/child1TypeName/child1ID/child2TypeName/child2ID/…</literal></para>

		<para>For example, a particular <literal><olink targetptr="core_sense">sense</olink></literal> (which is a property of <literal><olink targetptr="core_entry">entry</olink></literal>) is assigned the following IRI:</para>

		<para><literal>lexicographicResource.uri/entry/entryID/sense/senseID</literal></para>

		<para>IRI of an <literal><olink targetptr="core_example">example</olink></literal> (which is a property of <literal><olink targetptr="core_sense">sense</olink></literal>, which is a property of <literal><olink targetptr="core_entry">entry</olink></literal>) has the following structure:</para>

		<para><literal>lexicographicResource.uri/entry/entryID/sense/senseID/example/exampleID</literal></para>

		<section id="objectids">
			<title>Object IDs</title>

			<para>For the purpose of creating IRIs, each object is assigned a unique ID, based on values of its properties declared as <glossterm>unique</glossterm>. Multiple situations can occur:</para>

			<orderedlist>
				<listitem>The object type has a single <glossterm>unique</glossterm> property with an arity of “exactly one”, and the value of the property is a string or a number. In this case, the object ID is the string or the number, with the following modifications performed in that particular order:
					<itemizedlist>
						<listitem>every “\” (ASCII character 5C) is replaced by “\\”</listitem>
						<listitem>every “~” (ASCII character 7E) is replaced by “\~”</listitem>
						<listitem>every “_” (ASCII character 5F) is replaced by “\_”</listitem>
						<listitem>all IRI-unsafe characters (outside the <literal>iunreserved</literal> class according to [<link linkend="bib_rfc3987">RFC 3987</link>]) are percent-encoded according to [<link linkend="bib_rfc3986">RFC 3986</link>]</listitem>
					</itemizedlist>
				</listitem>
				<listitem>The object type has a single <glossterm>unique</glossterm> property with an arity of “exactly one”, and the value of the property is a child DMLex object. In this case, the object ID is the same as the object ID of the child object. (Note: this case actually does not occur in the specification as such; we list it here to streamline the description of the following cases.)</listitem>
				<listitem>The object type has a single <glossterm>unique</glossterm> property with an arbitrary arity. In this case, all the partial single values or child object IDs are constructed according to the steps 1. and 2., and the resulting object ID is their concatenation using “_” (ASCII character 5F) as a separator. The order of the partial values is driven by the <literal>listingOrder</literal> of the respective objects. (Note: this allows empty IDs in case of <glossterm>unique</glossterm> attributes which allow the arity of zero.)</listitem>
				<listitem>The object type has multiple <glossterm>unique</glossterm> properties. In this case, all the partial values or child object IDs are constructed according to the steps 1., 2. and 3., and the resulting object ID is their concatenation using “~” (ASCII character 5F) as a separator. The order of the partial values is driven by the order of the properties as given in this specification. (Note: this allows empty IDs in case of multiple <glossterm>unique</glossterm> attributes, all of them allowing the arity of zero.)</listitem>
			</orderedlist>

			<para>DMLex does not define the structure of IRIs for object types without <glossterm>unique</glossterm> properties.</para>
		</section>
		<section id="iri_examples">
			<title>IRI examples</title>
			<para>Particular IRI examples can then look as follows:</para>
			<itemizedlist>
				<listitem><literal>http://www.example.com/lexicon/entry/cat~1~noun</literal></listitem>
				<listitem><literal>http://www.example.com/lexicon/entry/cat~1~noun/sense/small%20furry%20animal</literal></listitem>
				<listitem><literal>http://www.example.com/lexicon/entry/cat~1~noun/sense/small%20furry%20animal/example/I%20have%20two%20dogs%20and%20a%20cat.</literal></listitem>
			</itemizedlist>
		</section>
	  </section>
  </section>
  <xi:include href="objectTypes/lexicographicResource.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/entry.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/partOfSpeech.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/inflectedForm.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/sense.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/definition.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/label.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/pronunciation.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/transcription.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  <xi:include href="objectTypes/example.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
</section>
